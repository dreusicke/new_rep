<!DOCTYPE HTML>
<html>
	<head>
		<meta name="viewport" content="initial-scale=1.0, user-scalable=no"/>
		<meta charset="UTF-8">
		<script type="text/javascript" src="http://maps.google.com/maps/api/js?sensor=true"></script>
		<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
		<link rel="stylesheet" type="text/css" href="css.css">
	</head>

	<body>
		<div id="story">
			<h1>Sense my city</h1>
			<h3>Projektbeschreibung</h3>
			<p>Hier steht unsere Geschichte.</p>
		</div>
		<img scr="/img/storyboard_2a.png" alt="Abbildung Storyboard 2a" width="200px" height="200px">
		<h3>Karte von Straßenlaternen in Berlin</h3>
		<form class="button">

			<input type="button" value="Show car traffic" class="button" onClick="alert('yes!');">
			<input type="button" value="Show car traffic really" class="button" onClick="cars">
			<input type="button" value="no function yet" class="button">
			<div id="tooltip" class="hidden">
				<p class="infobox">
				<table>
					<tbody>
						<tr><td class="thead" colspan="2">Details for street light</td></tr>
						<tr><td class="td_name">Name of the lamp</td><td class="td_data"><span id="name_lamp">dummie</span></td></tr>
						<tr><td class="td_name">Installation date</td><td class="td_data"><span id="installed">dummie</span></td></tr>
						<tr><td class="td_name">Bulb</td><td class="td_data"><span id="bulb">dummie</span></td></tr>
						<tr><td class="td_name">Type of bulb</td><td class="td_data"><span id="type_bulb">dummie</span></td></tr>
						<tr><td class="td_name">Power output in Watt</td><td class="td_data"><span id="watt">dummie</span></td></tr>
						<tr><td class="td_name">Energy consumption</td><td class="td_data"><span id="energy_consumption">dummie</span></td></tr>
						<tr><td class="td_name">Light output in Lumen</td><td class="td_data"><span id="lumen">dummie</span></td></tr>
						<tr><td class="td_name">Energy efficiency</td><td class="td_data"><span id="lumen_per_watt">dummie</span></td></tr>
						<tr><td class="td_name">Efficiency class</td><td class="td_data"><span id="energy_efficiency">dummie</span></td></tr>
						<tr><td class="td_name">Powered</td><td class="td_data"><span id="powered">dummie</span></td></tr>
					</tbody>
				</table>

				</p>
			</div>

		</form>

	<div id="map"></div>

	<h3>Nächste Visualisierung</h3>
	<p>Hier leiten wir über zur nächsten Visualisierung mit einigem Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text . </p>
	</div>




<script type="text/javascript">


	//      CREATE GOOGLE MAP

	var map = new google.maps.Map(document.getElementById('map'), {
		center: new google.maps.LatLng(52.5377, 13.4281),
		//zoom: 17, // (good for one street)
		zoom: 15,
		mapTypeId: google.maps.MapTypeId.ROADMAP,
		styles: 
		[
			{
				"stylers": [
					{ "invert_lightness": true },
					{ "gamma": 0.93 },
					{ "lightness": -39 },
					{ "saturation": -81 }
				]
			},{
				"featureType": "road",
				"stylers": [
					{ "saturation": -40 },
					{ "lightness": 4 },
					{ "gamma": 1.04 }
				]
			}
		]
	});

	// google.maps.event.addListener(map, "click", function(){
	//    alert("Map clicked");
	// });

	//  IMPORT DATA FOR SCHOENHAUSER ALLEE FROM EXTERNAL FILE

	var importFunction3 = d3.dsv(";","text/csv");

	//  Load the station data. When the data comes back, create an overlay.
	importFunction3("schoenhauser_allee.csv", function(data) {
		//    console.log(data);

		//  CREATE COLOR SCALE FOR DATAPOINTS

		var height_min = d3.min(data, function(d) {
			return d.lumen/d.watt;
			console.log(d.lumen/d.watt);
		});
		var height_max = d3.max(data, function(d) {
			return d.lumen/d.watt;
		});

		var height_scale = d3.scale.linear()
		.domain([height_min,height_max])
		.range(["#ff0000","#FFD700"]);


		//    CREATE OVERLAY FOR GOOGLE MAPS

		var overlay = new google.maps.OverlayView();

		// Add the container when the overlay is added to the map.
		overlay.onAdd = function() {
			var layer = d3.select(this.getPanes().overlayMouseTarget).append("div")
			.attr("class", "datapoints");


			//    DRAW DATAPOINTS FOR LIGHTS WITH SVG

			// Draw each marker as a separate SVG element. We could use a single SVG, but what size would it have?
			overlay.draw = function() {
				var projection = this.getProjection()
				var padding = 10;

				//    var test = layer.selectAll("svg").data(data);
				//    console.log("test "+test);

				var radius = function(d) {return d.lumen/10000+3;};

				var marker = layer.selectAll("svg")
				.data(data)
				.each(transform) // update existing markers
				.enter().append("svg:svg")
				.each(transform)
				.attr("class", "marker")
				.style("height", function(d) {return (d.lumen/10000+3)*4;})
				.style("width", function(d) {return (d.lumen/10000+3)*4;});

				var tooltip = d3.select("body").append("div")
				.attr("class", "tooltip")
				.style("opacity", 0);


				// Add the VISIBLE circle
				marker.append("svg:circle")
				.attr("r", radius)
				.attr("cx", function(d) {return (d.lumen/10000+3)*2;})
				.attr("cy", function(d) {return (d.lumen/10000+3)*2;})
				.attr("class", "circle")

				.style("position", "absolut")
				.style("fill", function(d) {return height_scale(d.lumen/d.watt);})
				.style("stroke-opacity", .7)
				.style("stroke-width", function(d) {return d.lumen/10000+6;})
				.style("stroke-opacity", .3)
				.style("stroke", function(d) {return height_scale(d.lumen/d.watt);})

				.on("mouseover", function(d) {
					tooltip.html(d)
					d3.select(this).attr("class", "circleHighlighted").transition().duration(100)

					d3.select("#tooltip").select("#name_lamp").text(d.name_lamp)
					d3.select("#tooltip").select("#installed").text(d.installed)
					d3.select("#tooltip").select("#bulb").text(d.bulb)
					d3.select("#tooltip").select("#type_bulb").text("Natrium vapor discharge lamp")
					d3.select("#tooltip").select("#watt").text(d.watt + " W")
					d3.select("#tooltip").select("#energy_consumption").text(d.energy_consumption + " kWh")
					d3.select("#tooltip").select("#lumen").text(d.lumen + " lm")
					d3.select("#tooltip").select("#lumen_per_watt").text(d.lumen/d.watt + " lm/W")
					d3.select("#tooltip").select("#energy_efficiency").text(d.energy_efficiency)
					d3.select("#tooltip").select("#powered").text("From 9.46pm to 4.34am")
					d3.select("#tooltip").style("opacity", .9).transition().duration(100);
				})

				.on("mouseout", function() {
					d3.select("#tooltip").style("opacity", 0)
					d3.select("#tooltip").classed("circleHighlighted", false).transition().duration(500);
					d3.select(this).classed("hidden", true).transition().duration(500);
				})

				function transform(d) {
					//          console.log("d "+d);
					data_point = new google.maps.LatLng(normalize(d.lat), normalize(d.lon));
					data_point_projected = projection.fromLatLngToDivPixel(data_point);
					return d3.select(this)
					.style("left", (data_point_projected.x - padding) + "px")
					.style("top", (data_point_projected.y - padding) + "px");
				}

				function normalize(coordinate) {
					// console.log("coordinate: "+coordinate);
					if (coordinate > 1000) return coordinate / 100000;
					else return coordinate;
				}

				function getColor(value){
					//          console.log("value "+value);
					if (value > 4) return "red";
					else return "green";
				}
			};
		};

		// Bind our overlay to the map…
		overlay.setMap(map);
	});

	//  IMPORT DATA FOR PRENZLAUER ALLEE FROM EXTERNAL FILE

	var importFunction1 = d3.dsv(";","text/csv");

	//  Load the station data. When the data comes back, create an overlay.
	importFunction1("prenzlauer_allee.csv", function(data) {
		//    console.log(data);

		//  CREATE COLOR SCALE FOR DATAPOINTS

		var height_min = d3.min(data, function(d) {
			return d.lumen/d.watt;
			console.log(d.lumen/d.watt);
		});
		var height_max = d3.max(data, function(d) {
			return d.lumen/d.watt;
		});

		var height_scale = d3.scale.linear()
		.domain([height_min,height_max])
		.range(["#ff0000","#FFD700"]);


		//    CREATE OVERLAY FOR GOOGLE MAPS

		var overlay = new google.maps.OverlayView();

		// Add the container when the overlay is added to the map.
		overlay.onAdd = function() {
			var layer = d3.select(this.getPanes().overlayMouseTarget).append("div")
			.attr("class", "datapoints");


			//    DRAW DATAPOINTS FOR LIGHTS WITH SVG

			// Draw each marker as a separate SVG element. We could use a single SVG, but what size would it have?
			overlay.draw = function() {
				var projection = this.getProjection()
				var padding = 10;

				//    var test = layer.selectAll("svg").data(data);
				//    console.log("test "+test);

				var marker = layer.selectAll("svg")
				.data(data)
				.each(transform) // update existing markers
				.enter().append("svg:svg")
				.each(transform)
				.attr("class", "marker")
				.style("height", function(d) {return (d.lumen/10000+3)*4;})
				.style("width", function(d) {return (d.lumen/10000+3)*4;});


				var tooltip = d3.select("body").append("div")
				.attr("class", "tooltip")
				.style("opacity", 0);


				// Add the VISIBLE circle
				marker.append("svg:circle")
				.attr("r", function(d) {return d.lumen/10000+3;})
				//				.attr("cx", function(d) {return d.lumen/10000+3;})
				//				.attr("cy", padding)
				.attr("cx", function(d) {return (d.lumen/10000+3)*2;})
				.attr("cy", function(d) {return (d.lumen/10000+3)*2;})
				.attr("class", "circle")

				.style("position", "absolut")
				.style("fill", function(d) {return height_scale(d.lumen/d.watt);})
				.style("stroke-opacity", .7)
				.style("stroke-width", function(d) {return d.lumen/10000+6;})
				.style("stroke-opacity", .3)
				.style("stroke", function(d) {return height_scale(d.lumen/d.watt);})

				.on("mouseover", function(d) {
					tooltip.html(d)
					d3.select(this).attr("class", "circleHighlighted").transition().duration(100)

					d3.select("#tooltip").select("#name_lamp").text(d.name_lamp)
					d3.select("#tooltip").select("#installed").text(d.installed)
					d3.select("#tooltip").select("#bulb").text(d.bulb)
					d3.select("#tooltip").select("#type_bulb").text("Natrium vapor discharge lamp")
					d3.select("#tooltip").select("#watt").text(d.watt + " W")
					d3.select("#tooltip").select("#energy_consumption").text(d.energy_consumption + " kWh")
					d3.select("#tooltip").select("#lumen").text(d.lumen + " lm")
					d3.select("#tooltip").select("#lumen_per_watt").text(d.lumen/d.watt + " lm/W")
					d3.select("#tooltip").select("#energy_efficiency").text(d.energy_efficiency)
					d3.select("#tooltip").select("#powered").text("From 9.46pm to 4.34am")
					d3.select("#tooltip").style("opacity", .9).transition().duration(100);
				})

				.on("mouseout", function() {
					d3.select("#tooltip").style("opacity", 0)
					d3.select("#tooltip").classed("circleHighlighted", false).transition().duration(500);
					d3.select(this).classed("hidden", true).transition().duration(500);
				})

				function transform(d) {
					//          console.log("d "+d);
					data_point = new google.maps.LatLng(normalize(d.lat), normalize(d.lon));
					data_point_projected = projection.fromLatLngToDivPixel(data_point);
					return d3.select(this)
					.style("left", (data_point_projected.x - padding) + "px")
					.style("top", (data_point_projected.y - padding) + "px");
				}

				function normalize(coordinate) {
					// console.log("coordinate: "+coordinate);
					if (coordinate > 1000) return coordinate / 100000;
					else return coordinate;
				}

				function getColor(value){
					//          console.log("value "+value);
					if (value > 4) return "red";
					else return "green";
				}
			};
		};

		// Bind our overlay to the map…
		overlay.setMap(map);
	});




	//  TRAFFIC VISIALIZATION



	//  IMPORT DATA FOR TRAFFIC FROM EXTERNAL FILE

	var importFunction1 = d3.dsv(";","text/csv");

	//  Load the station data. When the data comes back, create an overlay.
	importFunction1("traffic_fake02.csv", function(data) {
		//     console.log(data);

		//  CREATE COLOR SCALE FOR DATAPOINTS

		var height_min = d3.min(data, function(d) {                 
			return d.cars;
			var param = "cars";
			return d[param];
		});
		var height_max = d3.max(data, function(d) {
			return d.cars;
		});

		var height_scale = d3.scale.linear()
		.domain([height_min,height_max])
		.range(["#006cff","#adff9a"]);



		//    CREATE OVERLAY FOR GOOGLE MAPS

		var overlay = new google.maps.OverlayView();

		// Add the container when the overlay is added to the map.
		overlay.onAdd = function() {
			var layer = d3.select(this.getPanes().overlayLayer).append("div")
			.attr("class", "datapoints");

			//    DRAW DATAPOINTS FOR heightS WITH SVG

			// Draw each marker as a separate SVG element. We could use a single SVG, but what size would it have?
			overlay.draw = function() {
				var projection = this.getProjection()
				var padding = 10;
				var radius = 10;

				//    var test = layer.selectAll("svg").data(data);
				//    console.log("test "+test);

				var marker = layer.selectAll("svg")
				.data(data)
				.each(transform) // update existing markers
				.enter().append("svg:svg")
				.each(transform)
				.attr("class", "marker")
				.style("height", 30)
				.style("width", 55)
//				.style("background-color", "white");

				//				// Add a circle.
				//				marker.append("svg:circle")
				//				//          .attr("r", function(d) {return d.height*1.1;})
				//				.attr("r", radius)
				//				.attr("cx", padding)
				//				.attr("cy", padding)
				//				.attr("class", "circle")
				//				// .on("click", function(){alert("test")}) // toDo: make markers clickable
				//				.style("fill", function(d) {return height_scale(d.cars);});

//				marker.append("svg:rect")
//				.attr("x", 0)
//				.attr("y", 0)
//				//				.attr("rx", 3)
//				//				.attr("ry", 3)
//				.attr("width", 15)
//				.attr("height", 15)
//				.style("fill", function(d) {return height_scale(d.cars);});

				marker.append("svg:path")
				
				.attr("d", "M48.52,34.51l-0.037-6.559c0-3.214-3.307-5.382-6.273-5.382H23.219l-2.879,8.373c0,0-10.541,0.039-13.05,0.039 S4.83,32.4,4.83,32.4v6.314c0,0.023,0.003,0.051,0.003,0.074H2.735v5.309h6.058c-0.073-0.377-0.114-0.762-0.114-1.158 c0-3.438,2.788-6.225,6.223-6.225c3.438,0,6.228,2.787,6.228,6.225c0,0.396-0.043,0.781-0.112,1.158h14.462 c-0.068-0.377-0.109-0.764-0.109-1.158c0-3.438,2.789-6.225,6.225-6.225c3.438,0,6.223,2.787,6.223,6.225 c0,0.406-0.041,0.805-0.113,1.189l3.703,0.047C52.559,35.503,48.52,34.51,48.52,34.51z M30.432,31.018h-6.728l1.795-6.729h4.933 V31.018z M40.897,31.167h-8.818V24.29h8.818V31.167z M15.042,38.337c-2.712,0-4.91,2.199-4.91,4.912s2.198,4.91,4.91,4.91 c2.713,0,4.911-2.197,4.911-4.91C19.954,40.536,17.755,38.337,15.042,38.337z M15.042,45.47c-1.226,0-2.218-0.994-2.218-2.221 c0-1.225,0.99-2.221,2.218-2.221c1.224,0,2.222,0.996,2.222,2.221C17.263,44.476,16.265,45.47,15.042,45.47z M41.506,38.337 c-2.713,0-4.912,2.199-4.912,4.912s2.199,4.91,4.912,4.91c2.711,0,4.91-2.197,4.91-4.91S44.217,38.337,41.506,38.337z M41.506,45.47 c-1.223,0-2.221-0.994-2.221-2.221c0-1.225,0.996-2.221,2.221-2.221s2.219,0.996,2.219,2.221 C43.725,44.476,42.731,45.47,41.506,45.47z")
				.attr("transform", "translate(0, -20)")
				.style("stroke-width", 2)
				.style("stroke", "steelblue")
				.style("fill", "green");

				function transform(d) {
					//          console.log("d "+d);
					data_point = new google.maps.LatLng(normalize(d.lat), normalize(d.lon));
					data_point_projected = projection.fromLatLngToDivPixel(data_point);
					return d3.select(this)
					.style("left", (data_point_projected.x - padding) + "px")
					.style("top", (data_point_projected.y - padding) + "px");
				}

				function normalize(coordinate) {
					// console.log("coordinate: "+coordinate);
					if (coordinate > 1000) return coordinate / 100000;
					else return coordinate;
				}

				function getColor(value){
					//          console.log("value "+value);
					if (value > 4) return "red";
					else return "green";
				}
			};
		};

		// Bind our overlay to the map…
		overlay.setMap(map);
	});




	////  IMPORT MORE DATA FROM ANOTHER EXTERNAL FILE
	//
	//var importFunction2 = d3.dsv(";","text/csv");
	//
	////  Load the station data. When the data comes back, create an overlay.
	//importFunction2("stops_vzz.csv", function(data) {
	//  //  console.log(data);
	//
	//
	//
	//
	//  //    CREATE OVERLAY FOR GOOGLE MAPS
	//
	//  var overlay2 = new google.maps.OverlayView();
	//
	//  // Add the container when the overlay2 is added to the map.
	//  overlay2.onAdd = function() {
	//    var layer2 = d3.select(this.getPanes().overlayLayer).append("div")
	//        .attr("class", "datapoints");
	//
	//  //    DRAW DATAPOINTS FOR STOPS WITH SVG
	//
	//    // Draw each marker as a separate SVG element. We could use a single SVG, but what size would it have?
	//    overlay2.draw = function() {
	//      var projection = this.getProjection()
	//      var padding = 20;
	//
	//      //    var test = layer2.selectAll("svg").data(data);
	//      //    console.log("test "+test);
	//
	//      var marker = layer2.selectAll("svg")
	//          .data(data)
	//          .each(transform2) // update existing markers
	//          .enter().append("svg:svg")
	//          .each(transform2)
	//          .attr("class", "marker");
	//
	//      // Add a circle.
	//      marker.append("svg:circle")
	//          .attr("r", "0.6em")
	//          .attr("cx", padding)
	//          .attr("cy", padding)
	//      //  .attr("class", "circle")
	//      //  .on("click", function(){alert("test")}) // toDo: make markers clickable
	//          .attr("fill-opacity", "0.7")
	//          .style("fill", "#fff500")
	//          .style("stroke-with", "0.5em")
	//          .style("stroke", "green");
	//
	////      Additional triangle just for pleasure
	////      marker.append("svg:path")
	////          .attr('d', function(d) { 
	////            var x = padding -10, y = padding - 15;
	////            return 'M ' + x +' '+ y + ' l 4 4 l -8 0 z'; //M: startcenter, l: draw line after walk, z: close shape
	////          })
	////          .attr("fill-opacity", "0.5")
	////          .style("fill", "#00d8ff");
	//
	////      Another shape for pleasure
	////      marker.append("svg:path")
	////        .attr('d', function(d) { 
	////          var x = padding -10 , y = padding - 5;
	////          return 'M ' + x +' '+ y + ' l 5 5 l -5 5 l -5 -5 z';
	////        })
	////        .attr("fill-opacity", "0.5")
	////        .style("fill", "#00d8ff");
	//
	//      marker.append("svg:text")
	//          .attr("x", padding - 3)
	//          .attr("y", padding)
	//          .attr("dy", ".31em")
	//      //  .attr("fill", function(d) {return height_scale(d.height - 1);}) //darker for better readability
	//          .attr("stroke", "green")
	//          .attr("fill-opacity", "0.7")
	//          .attr("font-size", "0.8em")
	////          .on("mouseover", function(d){d3.select(this).attr("fill-opacity", "1");}) // toDo: enable hover
	//          .text("H");
	//      
	//      // Add a label.
	//      marker.append("svg:text")
	//          .attr("x", padding + 13)
	//          .attr("y", padding)
	//          .attr("dy", ".31em")
	//          .attr("class", "label")
	//      //  .attr("fill", function(d) {return height_scale(d.height - 1);}) //darker for better readability
	//          .attr("fill", "white")
	//          .attr("fill-opacity", "0.3")
	////          .on("mouseover", function(d){d3.select(this).attr("fill-opacity", "1");}) // toDo: enable hover
	//          .text(function(d) { return d.stop_name;});
	//
	//      function transform2(d) {
	////          console.log("d "+d);
	//        data_point = new google.maps.LatLng(normalize2(d.lat), normalize2(d.lon));
	//        data_point_projected = projection.fromLatLngToDivPixel(data_point);
	//        return d3.select(this)
	//            .style("left", (data_point_projected.x - padding) + "px")
	//            .style("top", (data_point_projected.y - padding) + "px");
	//      }
	//
	//      function normalize2(coordinate) {
	//          // console.log("coordinate: "+coordinate);
	//          if (coordinate > 1000) return coordinate / 100000;
	//          else return coordinate;
	//      }
	////
	////      function getColor(value){
	////          console.log("value "+value);
	////          if (value > 4) return "red";
	////          else return "green";
	////      }
	//    };
	//  };
	//
	//  // Bind our overlay2 to the map…
	//  overlay2.setMap(map);
	//});
	//
	//      


</script>
</body>
</html>